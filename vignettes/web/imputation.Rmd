---
title: "Imputation of phosphoproteomics data with PhosR"
date: "`r BiocStyle::doc_date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Preprocessing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    warning = FALSE,
    message = FALSE,
    comment = "#>"
)
```

# Introduction

`PhosR` is a package for the all-rounded analysis of phosphoproteomic data from processing to downstream analysis. This vignette will provide a step-by-step workflow of how PhosR can be used to process and analyse a panel of phosphoproteomic datasets. As one of the first steps of data processing, we will begin by performing filtering and imputation of the data with `PhosR`.

# Loading packages and data

First, we will load the PhosR package. If you already haven't done so, please install PhosR as instructed in the main page.

```{r}
suppressPackageStartupMessages({
  library(PhosR)
})
```

## Setting up the data

We assume that you will have the raw data processed using platforms frequently used for mass-spectrometry based proteomics such as MaxQuant. For demonstration purposes, we will take a parts of phosphoproteomic data generated by [Humphrey et al.](doi:10.1038/nbt.3327) with accession number PXD001792. The dataset contains the phosphoproteomic quantifications of two mouse liver cell lines (Hepa1.6 and FL38B) that were treated with either PBS (mock) or insulin. 

Let us load the PhosphoExperiment (ppe) object.
```{r}
data("phospho.cells.Ins.pe")

ppe <- phospho.cells.Ins.pe 
class(ppe)
```

A quick glance of the object.
```{r}
ppe
```

We will take the grouping information from `colnames` of our matrix.
```{r}
grps = gsub("_[0-9]{1}", "", colnames(ppe))
```

For each cell line, there are two conditions (Control vs Insulin-stimulated) and 6 replicates for each condition. 
```{r}
# FL38B
gsub("Intensity.", "", grps)[1:12]
# Hepa1
gsub("Intensity.", "", grps)[13:24]
```

Note that there are in total 24 samples and 5,000 phosphosites profiled.
```{r}
dim(ppe)
```

# Filtering of phosphosites

Next, we will perform some filtering of phosphosites so that only phosphosites with quantification for at least 50% of the replicates in at least one of the conditions are retained. For this filtering step, we use the `selectGrps` function. The filtering leaves us with 1,772 phosphosites.
```{r}
ppe_filtered <- selectGrps(ppe, grps, 0.5, n=1) 
dim(ppe_filtered)
```

`selectGrps` gives you the option to relax the threshold for filtering. The filtering threshold can therefore be optimized for each dataset.
```{r}
# In cases where you have fewer replicates ( e.g.,triplicates), you may want to select phosphosites quantified in 70% of replicates. 
ppe_filtered_v1 <- selectGrps(ppe, grps, 0.7, n=1) 
dim(ppe_filtered_v1)
```

# Imputation of phosphosites

We can proceed to imputation now that we have filtered for suboptimal phosphosites. To take advantage of data structure and experimental design, PhosR provides users with a lot of flexibility for imputation. There are three functions for imputation: `scImpute`,`tInmpute`, and `ptImpute`. Here, we will demonstrate the use of `scImpute` and `ptImpute`.

## Site- and condition-specific imputation

The `scImpute` function is used for site- and condition-specific imputation. A pre-defined thereshold is used to select phosphosites to impute. Phosphosites with missing values equal to or greater than a predefined value will be imputed by sampling from the empirical normal distribution constructed from the quantification values of phosphosites from the same condition. 
```{r}
set.seed(123)
ppe_imputed_tmp <- scImpute(ppe_filtered, 0.5, grps)[,colnames(ppe_filtered)]
```

In the above example, only phosphosites that are quantified in more than 50% of samples from the same condition will be imputed. 

## Paired tail-based imputation

We then perform paired tail-based imputation on the dataset imputed with `scImpute`. Paired tail-based imputation performs imputation of phosphosites that have missing values in *all* replicates in one condition (e.g. in *basal*) but not in another condition (e.g., in *stimulation*). This method of imputation ensures that we do not accidentally filter phosphosites that seemingly have low detection rate.

As for `scImpute`, we can set a predefined threshold to in another condition (e.g. *stimulation*), the tail-based imputation is applied to impute for the missing values in the first condition.
```{r}
set.seed(123)
ppe_imputed <- ppe_imputed_tmp
ppe_imputed[,seq(6)] <- ptImpute(ppe_imputed[,seq(7,12)], 
                                 ppe_imputed[,seq(6)], 
                                 percent1 = 0.6, percent2 = 0, paired = FALSE)
ppe_imputed[,seq(13,18)] <- ptImpute(ppe_imputed[,seq(19,24)], 
                                     ppe_imputed[,seq(13,18)], 
                                     percent1 = 0.6, percent2 = 0, paired = FALSE)
```

Lastly, we perform normalisation of the filtered and imputed phosphoproteomic data. 
```{r}
ppe_imputed_scaled <- medianScaling(ppe_imputed, scale = FALSE, assay = "imputed")
```

# Quantification plots

A useful function in `PhosR` is to visualize the percentage of quantified sites before and after filtering and imputation. The main inputs of `plotQC` are the quantification matrix, sample labels (equating the column names of the matrix), an integer indicating the panel to plot, and lastly, a color vector. To visualize the percentage of quantified sites, use the `plotQC` function and set *panel = quantify* to visualise bar plots of samples. 

```{r}
p1 = plotQC(ppe_filtered@assays@data$Quantification, labels=colnames(ppe_filtered),
        panel = "quantify", grps = grps)
p2 = plotQC(ppe_imputed_scaled@assays@data$scaled, 
       labels=colnames(ppe_imputed_scaled), panel = "quantify", grps = grps)
ggpubr::ggarrange(p1, p2, nrow = 1)
```

By setting *panel = dendrogram*, we can visualise the results of unsupervised hierarchical clustering of samples as a dendrogram. The dendrogram demonstrates that imputation has improved the clustering of the samples so that replicates from the same conditions cluster together. 
```{r}
p1 = plotQC(ppe_filtered@assays@data$Quantification, 
       labels=colnames(ppe_filtered), panel = "dendrogram", 
       grps = grps)
p2 = plotQC(ppe_imputed_scaled@assays@data$scaled, 
       labels=colnames(ppe_imputed_scaled), 
       panel = "dendrogram", grps = grps)
ggpubr::ggarrange(p1, p2, nrow = 1)
```

We can now move onto the next step in the `PhosR` workflow: integration of datasets and batch correction.

# SessionInfo

```{r}
sessionInfo()
```
